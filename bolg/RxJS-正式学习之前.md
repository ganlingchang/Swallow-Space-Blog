由于公司项目技术栈要用到RxJS,对于我来说，是一门船新的技术。但是既然要使用这门技术，肯定是有它的独到之处。本系列文章记录一下自己的学习过程。

在正式学习RxJS之前，需要补充一些相关的知识。

### 什么是RxJS
RxJS 是实现了ReactiveX思想的JS版本
> ReactiveX来自微软，它是一种针对异步数据流的编程。简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装成流的形式，然后用强大丰富的操作符对流进行处理，使你能以同步编程的方式处理异步数据，并组合不同的操作符来轻松优雅的实现你所需要的功能。

> ReactiveX 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切。

### 观察者模式

核心思想是：观察者 -->(订阅) 被观察者。

当被观察者状态发生改变的时候，观察者针对观察到的变化，进行响应的处理。

响应式编程中运用了观察者模式。


### 响应式编程
什么是响应式编程？

小明18点下班，一种方法是他需要隔一段时间去看一下下班时间是否已经到了。另一种方法他可以设置一个闹钟，那么他只要听到了闹钟响，那么他就知道了，该下班了！

两种方式的区别：主动观察下班时间，效率较低，需要分散注意力，且可能会造成耽误下班。但是如果设置闹钟的话，在闹钟响之前，完全可以专心处理自己的事物，效率大大提升。

以上的例子，听到闹钟下班是针对响应做的处理，当然，也可以针对响应自定义操作。在软件编程中，这种思想可以称为**响应式编程**。

### 函数式编程
1. 函数是"第一等公民" 是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。（高阶函数的应用）


```
// 函数式编程
function add(value1, value2) {
    return value1 + value2
}

const array = []
array.reduce(add)

```


2. 引用透明 指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的


```
// 非函数式编程
const PI = 3.14
function calCircle(radius) {
    return PI * radius * radius
}

calCircle(5)

// 函数式编程

function calCircle(radius, PI) {
    return PI * radius * radius
}

```


3. 没有"副作用", 不修改状态 函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点


```
// 非函数式编程
let total = 0
function addTotal(num) {
    total += num
}

addTotal(30)
console.log(total) // 30

// 函数式编程
let total = 0
function addTotal(num) {
    return total + num
}

const result = addTotal(30)
console.log(total) // 0

```


#### 了解了学习RxJS需要相关概念之后，下一篇文章正式来开始学习RxJS



